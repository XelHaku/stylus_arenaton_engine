use crate::call_contract::{call_contract_method, call_contract_method_signed};
use crate::constants::env_vars::{get_env_vars, EnvVars};
use ethers::prelude::*;
use eyre::Result;
use std::sync::Arc;

use crate::constants::wallets::{Wallet, WALLETS};



/// Function to get the summary of a specific address
pub async fn summary(player_address: &str) -> Result<(U256, U256, U256, U256, U256)> {
    let abi_json = r#"[
        {
            "inputs": [
                { "internalType": "address", "name": "player", "type": "address" }
            ],
            "name": "summary",
            "outputs": [
                { "internalType": "uint256", "name": "", "type": "uint256" },
                { "internalType": "uint256", "name": "", "type": "uint256" },
                { "internalType": "uint256", "name": "", "type": "uint256" },
                { "internalType": "uint256", "name": "", "type": "uint256" },
                { "internalType": "uint256", "name": "", "type": "uint256" }
            ],
            "stateMutability": "view",
            "type": "function"
        }
    ]"#;

    let env = get_env_vars();

    let vault_address = env.vault_address;
    let rpc_url = env.rpc_url;
    let player: Address = player_address.parse()?;

    // Call the contract method and get the tuple of values
    let (val1, val2, val3, val4, val5): (U256, U256, U256, U256, U256) = call_contract_method(
        "summary",
        player, // Pass player as argument
        abi_json,
        &vault_address,
        &rpc_url,
    )
    .await?;

    println!(
        "\nSummary of {}: {}, {}, {}, {}, {}",
        player, val1, val2, val3, val4, val5
    );

    Ok((val1, val2, val3, val4, val5))
}


pub async fn initialize(erc20aton_address: &str,_wallet: &Wallet) -> Result<()> {
    // Correct ABI JSON for the `initialize` function
    let abi_json = r#"[
        {
            "inputs": [{ "internalType": "address", "name": "_aton_address", "type": "address" }],
            "name": "initialize",
            "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
            "stateMutability": "nonpayable",
            "type": "function"
        }
    ]"#;
    let env = get_env_vars();

    let vault_address = env.vault_address;
    let rpc_url = env.rpc_url;
    let chain_id = env.chain_id;

    // Create signer from private key
    let wallet = WALLETS[0]
        .private_key
        .parse::<LocalWallet>()?
        .with_chain_id(chain_id);
    let signer = Arc::new(SignerMiddleware::new(
        Provider::<Http>::try_from(rpc_url)?,
        wallet,
    ));

    // Convert the erc20aton_address to an Address type
    let aton_address: Address = erc20aton_address.parse()?;

    let receipt = call_contract_method_signed(
        "initialize",
        aton_address, // Pass the address argument here
        abi_json,
        &vault_address,
        signer,
        U256::zero(), // No value sent
    )
    .await?;

    match receipt {
        Some(receipt) => println!("\nTransaction successful: {:?}", receipt.gas_used),
        None => println!("\nTransaction executed successfully, but no receipt was returned."),
    }

    Ok(())
}

pub async fn accumulate_aton(amount: U256,_wallet: &Wallet) -> Result<()> {
    // Correct ABI JSON for the `accumulateAton` function
    let abi_json = r#"[
        {
            "inputs": [{ "internalType": "uint256", "name": "amount", "type": "uint256" }],
            "name": "accumulateAton",
            "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
            "stateMutability": "nonpayable",
            "type": "function"
        }
    ]"#;

    let env = get_env_vars();

    let vault_address = env.vault_address;
    let rpc_url = env.rpc_url;
    let chain_id = env.chain_id;

    // Create signer from private key
    let wallet =_wallet
        .private_key
        .parse::<LocalWallet>()?
        .with_chain_id(chain_id);
    let signer = Arc::new(SignerMiddleware::new(
        Provider::<Http>::try_from(rpc_url)?,
        wallet,
    ));

    // Call the contract method
    let receipt = call_contract_method_signed(
        "accumulateAton",
        amount, // Pass the uint256 argument
        abi_json,
        &vault_address,
        signer,
        U256::zero(), // No value sent
    )
    .await?;

    // Handle the transaction receipt
    match receipt {
        Some(receipt) => println!("\nTransaction successful: {:?}", receipt.gas_used),
        None => println!("\nTransaction executed successfully, but no receipt was returned."),
    }

    Ok(())
}


// /**
//  * This file was automatically generated by Stylus and represents a Rust program.
//  * For more information, please see [The Stylus SDK](https://github.com/OffchainLabs/stylus-sdk-rs).
//  */

// // SPDX-License-Identifier: MIT-OR-APACHE-2.0
// pragma solidity ^0.8.23;

// interface IVault  {
//     function atonAddress() external view returns (address);

//     function initialize(address _aton_address) external returns (bool);

//     function accumulateAton(uint256 amount) external returns (bool);

//     function accumulateAton2(uint256 amount) external returns (bool);

//     function summary(address player) external view returns (uint256, uint256, uint256, uint256, uint256);

//     function playerCommission(address player) external view returns (uint256);

//     function clearCommission(address player) external;

//     error Zero(address);

//     error UnauthorizedAccount(address);
// }